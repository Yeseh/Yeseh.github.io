<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>Going Native - Ahead of Time compilation in C# | Jesse's Blog</title><meta property="og:title" content="Going Native - Ahead of Time compilation in C# | Jesse's Blog"><meta name=twitter:title content="Going Native - Ahead of Time compilation in C# | Jesse's Blog"><meta itemprop=name content="Going Native - Ahead of Time compilation in C# | Jesse's Blog"><meta name=application-name content="Going Native - Ahead of Time compilation in C# | Jesse's Blog"><meta property="og:site_name" content="Awesome hugo blog"><meta name=description content><meta itemprop=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:locale" content="en"><meta name=language content="en"><meta itemprop=image content="https://blog.jessewellenberg.nl"><meta property="og:image" content="https://blog.jessewellenberg.nl"><meta name=twitter:image content="https://blog.jessewellenberg.nl"><meta name=twitter:image:src content="https://blog.jessewellenberg.nl"><meta property="og:type" content="article"><meta property="og:article:published_time" content="2023-06-08T13:00:00+0200"><meta property="article:published_time" content="2023-06-08T13:00:00+0200"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Going Native - Ahead of Time compilation in C#","author":{"@type":"Person","name":""},"datePublished":"2023-06-08","description":"","wordCount":2328,"mainEntityOfPage":"True","dateModified":"2023-12-19","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"Jesse\u0027s Blog"}}</script><meta name=generator content="Hugo 0.111.3"><link rel=canonical href=https://blog.jessewellenberg.nl/posts/2023/going-native-aot-with-csharp/><link href=/sass/main.min.0eebb6db90b4ec9f4444ef402f08421ee056025ba860df3d749a9f299d472008.css rel=stylesheet><link href=/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=/images/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon/favicon-16x16.png><link rel=manifest href=/images/favicon/site.webmanifest><link rel=mask-icon href=/images/favicon/safari-pinned-tab.svg color=#5bbad5><link rel="shortcut icon" href=/images/favicon/favicon.ico><meta name=msapplication-TileColor content="#2b5797"><meta name=msapplication-config content="/images/favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=icon type=image/svg+xml href=/images/favicon/favicon.svg></head><body data-theme=dark class=notransition><script src=https://blog.jessewellenberg.nl/js/themeLoader.min.4e9e1a253d543bbfec02e7f2460d9621e719fd739dc8a5256faa91cda6e12e03.js></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=/ class=logo><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title>Home</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg></a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentcolor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=/>Home</a></li><li><a class=menu-link href=/manual/>Manual</a></li><li><a class="menu-link active" href=/posts/>Posts</a></li><li class=menu-separator><span>|</span></li></ul><a id=mode href=#><svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>Going Native - Ahead of Time compilation in C#</h1><div class=post-meta><time datetime=2023-06-08T13:00:00+02:00 itemprop=datePublished>Jun 8, 2023</time></div></header><div class=page-content><h1 id=introduction>Introduction</h1><p>With .NET 8, Microsoft is further improving support for Native Ahead of Time compilation (AoT). This means that we can now compile our C# programs directly to native code, instead of IL. How does AoT differ from &rsquo;normal&rsquo; C# compilation? How do we use AoT? And what are the implications for the ecosystem?</p><h1 id=what-even-is-a-compilation>What even is a compilation?</h1><p>When we talk about compilation, we talk about <em>translating</em> a program from one language to another. Usually, we mean translating a higher-level programming language to code our computers can execute directly. I will refer to this type of code as &rsquo;native code&rsquo; from now on. There are many different ways to create native code from another language, and some developers make it their life&rsquo;s work to make this process as efficient as possible.</p><p>Normally, C# is not directly compiled into native code. Instead, it is translated into an intermediate language (IL). This intermediate language is then compiled into native code by the <em>Common Language Runtime</em> (CLR). This route may seem a little bit complicated, but it is for good reasons. The CLR can store all sorts of information about the program, and use this information to do some cool stuff while the program is being executed. For example, the CLR can take care of allocating memory and cleaning up memory that is no longer in use, so developers (mostly) don&rsquo;t have to worry about that anymore. It can also keep track of higher-order type information such as the methods and properties of a class. With all this information, the CLR can make targeted optimizations in real-time. Something that would be incredibly hard, if not impossible, to do if we compiled directly to native code.</p><p>This indirect model for compilation is very common in modern programming languages. JavaScript uses the V8 or SpiderMonkey engines and Java uses the JVM to perform very similar tasks to Dotnet&rsquo;s CLR. More general terms for programs like this are <em>virtual machines</em> or <em>language runtimes</em>.</p><p>You can think of the CLR as a kitchen assistant. They can tell you what the next step in the recipe is, where you can find the necessary tools and ingredients, and clean up after you. Sometimes they get in your way a little bit, but now you can focus on getting food out to your guests instead of worrying about the dishes.</p><h1 id=no-free-lunch>No free lunch</h1><p>Like always, there are tradeoffs to make. The CLR is a process that needs to be running for our program to execute. This means that we need to ship the CLR with our program or use something like a docker container with the CLR pre-installed. And while the runtime is very good at what it does, it is a pretty big application and it has a noticeable impact on both the startup time and the memory usage of our program. Which can be detrimental for some use cases. In embedded scenarios, for example, there is often very limited memory and disk space available to run and store applications. So every bit that we can save is a win.</p><p>This is where AoT comes in. Already available in .NET 7 but further stabilized with the release of .NET 8, AoT allows us to directly compile our C# programs to native code. When using AoT, we don&rsquo;t need the CLR to execute our C# code for us, but the computer can do it directly. This has a couple of major benefits:</p><ul><li>Single executable</li><li>Faster startup times</li><li>Smaller binary size</li><li>Smaller memory footprint</li></ul><p>Below you can find a graph that details the performance of AoT-compiled C# apps versus apps that are traditionally compiled:</p><img src=aot-runtime-trimmed-perf-chart.png alt="AoT Performance Comparison (from MS learn)" width=600><p>The performance increases seem pretty massive but again, there are no free lunches in software engineering.
Remember when I told you that the CLR can keep track of all sorts of information about our program? Well, we sacrifice most of that information when we compile directly to native code. For example, we can&rsquo;t use runtime reflection because the compiled code doesn&rsquo;t have any information about the higher-order types in our program anymore. We also can&rsquo;t use dynamic code generation, or assembly loading because of this. We don&rsquo;t strip out <em>all</em> the runtime features when AoT compiling. We still package parts of the dotnet runtime together with our application. The garbage collector still works, for example, so we don&rsquo;t suddenly have to do manual memory management if we turn on AoT.</p><p>This all has pretty big implications for existing codebases. As they, or their dependencies, often rely heavily on techniques like reflection. Take ASP.NET. When we define a POST request in ASP.NET, we can specify a C# type that represents the shape of the JSON request. The framework then uses reflection to create an instance of that type from the request body. Because the framework is using runtime reflection here, this won&rsquo;t work with AoT-compiled apps. To get this to work with AoT compilation, we need to have the logic to create the type from the request body in our codebase at the time of compilation. So we could, for example, write (or generate :) ) a source generator that creates this logic for us. Microsoft is doing exactly this in the background by steadily migrating systems that lean on runtime reflection to C# source generators, which create the necessary logic at compile time.</p><p>Because we can&rsquo;t directly use all the features of the dotnet runtime anymore, we need to do some extra work to make our code compatible with AoT compilation. This is also the case for the third-party libraries your projects depend on, they need to explicitly support AoT compilation. For larger code bases this task can be quite non-trivial. So unfortunately we can&rsquo;t just turn on AoT compilation and get all the benefits for free.</p><h1 id=why-would-you-use-aot>Why would you use AoT?</h1><p>I briefly mentioned the performance benefits of AoT compilation earlier, but why would you actually want to use it? Well, there are a couple of use cases where AoT compilation can be very useful.</p><p><strong>Embedded software</strong> - Embedded devices have CPUs that are often not very powerful. They also have small amounts of memory, and limited storage space, and might use instruction set architectures that are more specifically designed for what the devices are meant to do. With AoT compilation C# could be a viable option for these scenarios, as our applications get smaller footprints, become more portable, and can be specifically compiled for the target architecture.</p><p><strong>Serverless</strong> - Serverless functions are often used to run small pieces of code in response to events. Optimizing cold starts is very important for creating useful serverless systems. Native AoT can help in this case as it significantly reduces the start-up times of an application. This makes serverless apps more responsive and can save precious compute hours (money!).</p><p><strong>Polyglot Organizations</strong> - AoT compilation allows us to compile C# code to native code. This means that we can use C# to create libraries that can be consumed by other programming languages. This can be very useful in large organizations that use multiple programming languages across different teams. For example, we could use C# to create a library that can be consumed by an application written in C, Rust, or another native language. This way we can use the same codebase for multiple applications, and we don&rsquo;t have to rewrite the same logic in multiple languages. You can find a more detailed example of this later in this blog post.</p><p>In more general terms AoT compilation can help in any situation where start-up times and application footprint are important. It can make our applications run faster, deploy easier, scale better, and use fewer cloud resources. Whether or not this is worth the extra effort of making your codebase compatible with AoT compilation is greatly dependent on your use case. So it is very important to measure the performance and cost of your application. If you want to start experimenting with AoT compilation, I suggest looking at applications that use serverless architectures first. These codebases are often smaller and less complex. This makes them easier to port to AoT compilation, so you can evaluate the benefits of AoT within a reasonable timeframe.</p><h1 id=hello-native-c>Hello Native C#</h1><p>So how do we actually use AoT compilation? Let&rsquo;s look at a couple of basic examples and start with a good old Hello World console application:</p><blockquote><p>dotnet new console -o hello-world</p></blockquote><p>To compile this to a native executable we need to do two things. The first is enabling AoT compilation in our project file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=c>&lt;!--hello-world.csproj--&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;PropertyGroup&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c>&lt;!--...--&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;PublishAoT&gt;</span>true<span class=nt>&lt;/PublishAoT&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/PropertyGroup&gt;</span>
</span></span></code></pre></div><p>The second is actually compiling the application. We can do this with:</p><blockquote><p>dotnet publish -c &lt;config> -r &lt;rid></p></blockquote><p>This will create a native executable in the <code>bin/&lt;configuration>/net8.0/&lt;rid>/publish</code> folder. You might not be entirely familiar with the <code>-r</code> flag. This flag is used to specify the <em>runtime id</em> of the target platform for the executable. This is important because the native code that needs to be created is different for Windows than Linux for example. At the time of writing, we can only target the same platform as the one we&rsquo;re compiling the program on with AoT compilation. If you try to select a different target than your current operating system, you will get the following error message:</p><pre tabindex=0><code>&gt; error : Cross-OS native compilation is not supported
</code></pre><p>So if we&rsquo;re on Windows, we can only compile for Windows. If we&rsquo;re on Linux, we can only compile for Linux. We can however, cross-compile between architectures on the same operating system. So we can compile for Windows ARM on an x64 machine, or vice versa, as long as we have the right build tools installed for the target architecture. If you&rsquo;re interested, you can find a list of all the available runtime IDs <a href=https://docs.microsoft.com/en-us/dotnet/core/rid-catalog>here</a>. If we do want to compile for a different operating system, we could use a dockerfile to get this done. A Linux example would look something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> mcr.microsoft.com/dotnet/sdk:8.0 AS build</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Some extra dependencies are needed for AoT compilation on Linux</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> apt-get install clang zlib1g-dev -y<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /source</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> dotnet publish -c release -r linux-x64 -o /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> mcr.microsoft.com/dotnet/runtime-deps:8.0</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>build /app .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;/app/hello-world&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>There is one notable thing about this dockerfile. Namely, we can get away with using <code>dotnet/runtime-deps</code> instead of the usual <code>dotnet/runtime</code> image. We don&rsquo;t need the full dotnet runtime anymore, because we&rsquo;re compiling directly to native code. This makes our docker image much smaller.</p><h1 id=what-about-libraries>What about libraries?</h1><p>What if we want to consume a C# library from another programming language? With AoT we can also compile libraries to native code, which we can then consume in many different languages. This is slightly more involved than compiling a console application, but not by much. Let&rsquo;s start with a simple class library:</p><blockquote><p>dotnet new classlib -o aot-lib</p></blockquote><p>Again we need to add the <code>PublishAoT</code> property to our project file first. Let&rsquo;s add a method to this library:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>namespace</span> <span class=nn>aot_lib</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Class1</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=na>    [UnmanagedCallersOnly(EntryPoint = &#34;multiply&#34;)]</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>Multiply</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span> <span class=p>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>There are a couple of things to note here. First is that <em>all</em> exposed methods need to be static. The second is the <code>UnmanagedCallersOnly</code> attribute. &lsquo;Unmanaged&rsquo; in this context, means something like &lsquo;outside the influence of the dotnet runtime&rsquo;. That makes sense, considering we are not using the runtime to execute functions in this library. The unmanaged caller would be another program that calls into our C# library. The <code>EntryPoint</code> property in the attribute specifies the name of the function as it is exposed to consumers of the library.</p><p>We can now compile this library to native code:</p><blockquote><p>dotnet publish -c &lt;config> -r &lt;rid> /p:NativeLib=Shared</p></blockquote><p>This command will emit a &lsquo;shared&rsquo; library (.dll on Windows, .so on Linux) in the publish folder for the target rid. We could also use <code>NativeLib=Static</code> to emit a static library (.lib on Windows, .a on Linux). This is useful if we want to link the library directly to another native executable or library, but that is a little bit out of scope for this post.</p><p>To give you a quick demonstration of using the library we just built, we can use the following C program. For the sake of compactness, I will limit this example to Linux. You can find a complete example with platform-independent loading <a href=https://github.com/dotnet/samples/blob/main/core/nativeaot/NativeLibrary/LoadLibrary.c>here</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// LoadLibrary.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;dlfcn.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define LibPath &#34;./bin/Release/net8.0/linux-x64/publish/libcsharp.so&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check if the library file exists
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>access</span><span class=p>(</span><span class=n>LibPath</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Couldn&#39;t find library at the specified path&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Load the library and define our multiply function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>libhandle</span> <span class=o>=</span> <span class=nf>dlopen</span><span class=p>(</span><span class=n>LibPath</span><span class=p>,</span> <span class=n>RTLD_LAZY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>MultiplyFunc</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Lookup the multiply function in the library
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Note the lowercase &#39;multiply&#39; 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//This is the EntryPoint specified in UnmanagedCallersOnly
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MultiplyFunc</span> <span class=n>multiply</span> <span class=o>=</span> <span class=p>(</span><span class=n>MultiplyFunc</span><span class=p>)</span><span class=nf>dlsym</span><span class=p>(</span><span class=n>libhandle</span><span class=p>,</span> <span class=s>&#34;multiply&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Call the multiply function and output
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=nf>multiply</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Sum is %i</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Simply compile and run this program with (assuming you have clang installed):</p><blockquote><p><code>clang LoadLibrary.c && ./a.out</code></p></blockquote><p>You should see the following output:</p><blockquote><p>Sum is 16</p></blockquote><h1 id=conclusion>Conclusion</h1><p>To summarize: AoT compilation allows us to compile C# programs directly to native code. It leads to faster startup times, smaller binaries, and a smaller memory footprint. But, we can&rsquo;t use all the features of the dotnet runtime anymore, and so it requires a non-trivial amount of work to make existing codebases compatible with AoT compilation.</p><p>And that&rsquo;s it! Now you know how to build native executables and libraries with C#. There is plenty more to talk about that I didn&rsquo;t have space for in this introductory blog. Some future topics I might cover are:</p><ul><li>Building Native ASP.NET applications</li><li>Native library development with C#</li><li>Converting existing codebases to AoT</li></ul><h2 id=about-jesse><em>About Jesse</em></h2><p><em>Jesse is a software and cloud engineer at <a href=https://xebia.com>Xebia</a> in the Netherlands. His technical interests are currently focussed on Programming Languages, WebAssembly, and platform engineering. Learn more about him in his <a href=https://blog.jessewellenberg.nl/manual/>Manual</a></em></p></div></article></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons><a href=https://github.com/yeseh target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://linkedin.com/in/jesse-wellenberg target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div><small class=footer_copyright>Â© 2023 Jesse Wellenberg.
Powered by <a href=https://github.com/hugo-sid/hugo-blog-awesome target=_blank rel="noreferrer noopener">Hugo blog awesome</a>
theme on
<a href=https://gohugo.io target=_blank rel="noreferrer noopener">Hugo</a>.</small></footer><script src=https://blog.jessewellenberg.nl/js/themeSwitchnMenu.min.2a402288242b6930b175a0722c267e2353055739b3975834df35e56d00dd8f50.js></script></body></html>